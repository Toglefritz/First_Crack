part of '../push_notification_service.dart';

/// Represents a user tap on a notification action button.
///
/// This model encapsulates all the information needed to handle a notification action tap, including the action type,
/// associated brew ID, and deep link URL for navigation.
///
/// The data is received from native iOS/macOS code via method channel when a user taps an action button on a
/// notification.
class NotificationActionTap {
  /// The action that was tapped.
  ///
  /// This enum value identifies which action button the user pressed, allowing the app to respond appropriately (e.g.,
  /// pause grinding, view live extraction, etc.).
  final NotificationAction action;

  /// The brew ID associated with the notification.
  ///
  /// This unique identifier links the action to a specific brew session, allowing the app to navigate to the correct
  /// brew details or perform actions on the right brew.
  final String brewId;

  /// The deep link URL for navigation.
  ///
  /// This URL is generated by the native code based on the action and brew ID. The Flutter app can use this URL to
  /// navigate to the appropriate screen.
  ///
  /// Format: firstcrack://brew/{brewId}/{action} Example: firstcrack://brew/brew_123/pause
  final String deepLink;

  /// Creates a new notification action tap.
  ///
  /// All parameters are required as they are essential for handling the action properly.
  const NotificationActionTap({
    required this.action,
    required this.brewId,
    required this.deepLink,
  });

  /// Creates a NotificationActionTap from a map.
  ///
  /// This factory constructor is used to parse action tap data received from the method channel. The map is sent from
  /// native iOS/macOS code when a user taps an action button.
  factory NotificationActionTap.fromMap(Map<dynamic, dynamic> map) {
    // Extract and validate action identifier
    final String? actionIdentifier = map['action'] as String?;
    if (actionIdentifier == null || actionIdentifier.isEmpty) {
      throw ArgumentError('Missing or empty action identifier in map');
    }

    // Extract and validate brew ID
    final String? brewId = map['brewId'] as String?;
    if (brewId == null || brewId.isEmpty) {
      throw ArgumentError('Missing or empty brewId in map');
    }

    // Extract and validate deep link
    final String? deepLink = map['deepLink'] as String?;
    if (deepLink == null || deepLink.isEmpty) {
      throw ArgumentError('Missing or empty deepLink in map');
    }

    // Convert action identifier to enum
    final NotificationAction action = NotificationAction.fromIdentifier(actionIdentifier);

    return NotificationActionTap(
      action: action,
      brewId: brewId,
      deepLink: deepLink,
    );
  }

  /// Converts this action tap to a map.
  ///
  /// This method serializes the action tap data to a map for storage or transmission. The map structure matches the
  /// format expected by fromMap.
  Map<String, dynamic> toMap() {
    return <String, dynamic>{
      'action': action.toIdentifier(),
      'brewId': brewId,
      'deepLink': deepLink,
    };
  }

  @override
  String toString() {
    return 'NotificationActionTap(action: ${action.toIdentifier()}, brewId: $brewId, deepLink: $deepLink)';
  }
}
